[alias]
  c = checkout
  cp = checkout --patch
  # checkout pull-request.  This assumes pull requests exist as refs under
  # refs/pull/<n>
  cpr = "!f() { git checkout -b pull/$1 pull-requests/$1; }; f"

  b = branch
  br = branch -r
  backup = "!f() { local name=`git name-rev HEAD | cut -d' ' -f 2`; git branch -D \"backup/$name\" 2> /dev/null; git branch \"backup/$name\"; }; f"

  branch-current = "!f() { git branch --no-color | grep '*' | grep -v '(no branch)' | cut -c 3-; }; f"

  wm = !sh -c 'git merge $0 && git branch -d $0'
	ff = merge --ff-only

  # Rebase remote (origin/master) interactive
  rri = "!f() { git fetch origin && git rebase --autosquash --interactive origin/master \"$@\"; }; f"
  # Rebase fork-point
  rrf = "!f() { git rebase --autosquash --interactive `git fpm` \"$@\"; }; f"
  rc = rebase --continue

  # Depends on git-cleanup-my-branches
	cu = cleanup-my-branches


[branch]
  # always rebase to tracked branches on pull, for branches created by
  # `git branch` or `git checkout`, i.e. non-master.
  autosetuprebase = always

[mergetool]
	keepBackup = false
[rebase]
	autosquash = true
[merge]
	tool = gvimdiff
[rerere]
	enabled = 1

# vim:ft=gitconfig:
